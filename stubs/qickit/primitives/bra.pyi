import numpy as np
import qickit.primitives.ket as ket
import qickit.primitives.operator as operator
from numpy.typing import NDArray
from qickit.types import Scalar
from typing import overload

__all__ = ['Bra']

class Bra:
    label: str
    norm_scale: np.float64
    data: NDArray[np.complex128]
    shape: tuple[int, int]
    num_qubits: int
    def __init__(self, data: NDArray[np.complex128], label: str | None = None) -> None: ...
    @staticmethod
    def check_normalization(data: NDArray[np.number]) -> bool: ...
    normalized: bool
    def is_normalized(self) -> None: ...
    @staticmethod
    def normalize_data(data: NDArray[np.number], norm_scale: np.float64) -> NDArray[np.number]: ...
    def normalize(self) -> None: ...
    @staticmethod
    def check_padding(data: NDArray[np.number]) -> bool: ...
    padded: bool
    def is_padded(self) -> None: ...
    @staticmethod
    def pad_data(data: NDArray[np.number], target_size: int) -> tuple[NDArray[np.number], tuple[int, ...]]: ...
    def pad(self) -> None: ...
    def to_quantumstate(self) -> None: ...
    def to_bra(self, data: NDArray[np.number]) -> None: ...
    def to_ket(self) -> ket.Ket: ...
    def compress(self, compression_percentage: float) -> None: ...
    def __add__(self, other: Bra) -> Bra: ...
    @overload
    def __mul__(self, other: Scalar) -> Bra: ...
    @overload
    def __mul__(self, other: ket.Ket) -> Scalar: ...
    @overload
    def __mul__(self, other: operator.Operator) -> Bra: ...
    def __rmul__(self, other: Scalar) -> Bra: ...
