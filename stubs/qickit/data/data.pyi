import numpy as np
from numpy.typing import NDArray
from qickit.types import NestedCollection

__all__ = ['Data']

NumberType = int | float | complex


class Data:
    data: NestedCollection[NumberType]
    shape: tuple[int, ...]
    norm_scale: float
    num_qubits: int
    def __init__(self, data: NestedCollection[NumberType]) -> None: ...
    @staticmethod
    def check_normalization(data: NDArray[np.number]) -> bool: ...
    normalized: bool
    def is_normalized(self) -> None: ...
    @staticmethod
    def normalize_data(data: NDArray[np.number], norm_scale: np.float64) -> NDArray[np.number]: ...
    def normalize(self) -> None: ...
    @staticmethod
    def denormalize_data(data: NDArray[np.number], norm_scale: np.float64) -> NDArray[np.number]: ...
    def denormalize(self) -> None: ...
    @staticmethod
    def check_padding(data: NDArray[np.number]) -> bool: ...
    padded: bool
    def is_padded(self) -> None: ...
    @staticmethod
    def pad_data(data: NDArray[np.number]) -> tuple[NDArray[np.number], tuple[int, ...]]: ...
    def pad(self) -> None: ...
    def to_quantumstate(self) -> None: ...
    def compress(self, compression_percentage: float) -> None: ...
    def draw(self) -> None: ...
    @staticmethod
    def iscloseto(first_data: object, second_data: object, tolerance: float = 1e-08) -> bool: ...
    def change_indexing(self, index_type: str) -> None: ...
    def __eq__(self, other_data: object) -> bool: ...
    def __len__(self) -> int: ...
    def __mul__(self, multiplier: float) -> None: ...
