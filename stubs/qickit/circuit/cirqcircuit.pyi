import numpy as np
import cirq
from numpy.typing import NDArray
from qickit.backend import Backend
from qickit.circuit import Circuit
from qickit.synthesis.unitarypreparation import UnitaryPreparation
from qickit.types import Collection
from typing import Literal

__all__ = ["CirqCircuit"]

class CirqCircuit(Circuit):
    qr: cirq.LineQubit
    circuit: cirq.Circuit
    def __init__(self, num_qubits: int) -> None: ...
    def _single_qubit_gate(self,
                           gate: Literal["I", "X", "Y", "Z", "H", "S", "T", "RX", "RY", "RZ"],
                           qubit_indices: int | Collection[int],
                           angle: float=0) -> None: ...
    def U3(self, angles: Collection[float], qubit_index: int) -> None: ...
    def SWAP(self, first_qubit: int, second_qubit: int) -> None: ...
    def _controlled_qubit_gate(self,
                               gate: Literal["I", "X", "Y", "Z", "H", "S", "T", "RX", "RY", "RZ"],
                               control_indices: int | Collection[int],
                               target_indices: int | Collection[int],
                               angle: float=0) -> None: ...
    def MCU3(self, angles: Collection[float], control_indices: int | Collection[int], target_indices: int | Collection[int]) -> None: ...
    def MCSWAP(self, control_indices: int | Collection[int], first_target_index: int, second_target_index: int) -> None: ...
    def GlobalPhase(self, angle: float) -> None: ...
    measured: bool
    def measure(self, qubit_indices: int | Collection[int]) -> None: ...
    def get_statevector(self, backend: Backend | None = None) -> NDArray[np.complex128]: ...
    def get_counts(self, num_shots: int, backend: Backend | None = None) -> dict: ...
    def get_depth(self) -> int: ...
    def get_unitary(self) -> NDArray[np.complex128]: ...
    def transpile(self, direct_transpile: bool=True, synthesis_method: UnitaryPreparation | None = None) -> None: ...
    def to_qasm(self, qasm_version: int=2) -> str: ...
    def draw(self) -> None: ...
