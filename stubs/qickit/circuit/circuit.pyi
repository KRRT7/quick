import abc
import cirq
from collections.abc import Sequence
import matplotlib.pyplot as plt
import numpy as np
import pennylane as qml # type: ignore
import pytket
import qiskit # type: ignore
from abc import ABC, abstractmethod
from numpy.typing import NDArray
from qickit.backend import Backend
from qickit.synthesis.unitarypreparation import UnitaryPreparation
from types import NotImplementedType
from typing import Any, Literal, Type

__all__ = ["Circuit"]

class Circuit(ABC, metaclass=abc.ABCMeta):
    num_qubits: int
    circuit: Any
    measured: bool
    circuit_log: list[dict]
    def __init__(self, num_qubits: int) -> None: ...
    def convert_param_type(self, value: Any) -> list | int | float: ...
    def validate_qubit_index(self, name: str, value: Any) -> Any: ...
    def validate_angle(self, name: str, value: Any) -> Any: ...
    def process_gate_params(self, gate: str, params: dict) -> None: ...
    @abstractmethod
    def _single_qubit_gate(self,
                           gate: Literal["I", "X", "Y", "Z", "H", "S", "Sdg", "T", "Tdg", "RX", "RY", "RZ"],
                           qubit_indices: int | Sequence[int],
                           angle: float=0) -> None: ...
    @abstractmethod
    def _controlled_qubit_gate(self,
                               gate: Literal["X", "Y", "Z", "H", "S", "Sdg", "T", "Tdg", "RX", "RY", "RZ"],
                               control_indices: int | Sequence[int],
                               target_indices: int | Sequence[int],
                               angle: float=0) -> None: ...
    def Identity(self, qubit_indices: int | Sequence[int]) -> None: ...
    def X(self, qubit_indices: int | Sequence[int]) -> None: ...
    def Y(self, qubit_indices: int | Sequence[int]) -> None: ...
    def Z(self, qubit_indices: int | Sequence[int]) -> None: ...
    def H(self, qubit_indices: int | Sequence[int]) -> None: ...
    def S(self, qubit_indices: int | Sequence[int]) -> None: ...
    def Sdg(self, qubit_indices: int | Sequence[int]) -> None: ...
    def T(self, qubit_indices: int | Sequence[int]) -> None: ...
    def Tdg(self, qubit_indices: int | Sequence[int]) -> None: ...
    def RX(self, angle: float, qubit_indices: int | Sequence[int]) -> None: ...
    def RY(self, angle: float, qubit_indices: int | Sequence[int]) -> None: ...
    def RZ(self, angle: float, qubit_indices: int | Sequence[int]) -> None: ...
    @abstractmethod
    def U3(self, angles: Sequence[float], qubit_index: int) -> None: ...
    @abstractmethod
    def SWAP(self, first_qubit_index: int, second_qubit_index: int) -> None: ...
    def CX(self, control_index: int, target_index: int) -> None: ...
    def CY(self, control_index: int, target_index: int) -> None: ...
    def CZ(self, control_index: int, target_index: int) -> None: ...
    def CH(self, control_index: int, target_index: int) -> None: ...
    def CS(self, control_index: int, target_index: int) -> None: ...
    def CSdg(self, control_index: int, target_index: int) -> None: ...
    def CT(self, control_index: int, target_index: int) -> None: ...
    def CTdg(self, control_index: int, target_index: int) -> None: ...
    def CRX(self, angle: float, control_index: int, target_index: int) -> None: ...
    def CRY(self, angle: float, control_index: int, target_index: int) -> None: ...
    def CRZ(self, angle: float, control_index: int, target_index: int) -> None: ...
    def CU3(self, angles: Sequence[float], control_index: int, target_index: int) -> None: ...
    def CSWAP(self, control_index: int, first_target_index: int, second_target_index: int) -> None: ...
    def MCX(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCY(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCZ(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCH(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCS(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCSdg(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCT(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCTdg(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCRX(self, angle: float, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCRY(self, angle: float, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCRZ(self, angle: float, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    @abstractmethod
    def MCU3(self, angles: Sequence[float], control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    @abstractmethod
    def MCSWAP(self, control_indices: int | Sequence[int], first_target_index: int, second_target_index: int) -> None: ...
    @abstractmethod
    def GlobalPhase(self, angle: float) -> None: ...
    def unitary(self, unitary_matrix: NDArray[np.complex128], qubit_indices: int | Sequence[int]) -> None: ...
    def clbit_condition(self, clbit_index: int, value: int) -> None: ...
    def vertical_reverse(self) -> None: ...
    def horizontal_reverse(self, adjoint: bool = True) -> None: ...
    def add(self, circuit: Circuit, qubit_indices: int | Sequence[int]) -> None: ...
    @abstractmethod
    def measure(self, qubit_indices: int | Sequence[int]) -> None: ...
    def measure_all(self) -> None: ...
    @abstractmethod
    def get_statevector(self, backend: Backend | None = None, magnitude_only: bool=False) -> NDArray[np.complex128]: ...
    @abstractmethod
    def get_counts(self, num_shots: int, backend: Backend | None = None) -> dict[str, int]: ...
    @abstractmethod
    def get_depth(self) -> int: ...
    def get_width(self) -> int: ...
    @abstractmethod
    def get_unitary(self) -> NDArray[np.complex128]: ...
    def get_instructions(self, include_measurements: bool = True) -> list[dict]: ...
    def remove_measurements(self) -> Circuit: ...
    @abstractmethod
    def transpile(self, direct_transpile: bool=True, synthesis_method: UnitaryPreparation | None = None) -> None: ...
    def compress(self, compression_percentage: float) -> None: ...
    def change_mapping(self, qubit_indices: Sequence[int]) -> None: ...
    def convert(self, circuit_framework: Type[Circuit]) -> Circuit: ...
    def control(self, num_controls: int) -> Circuit: ...
    @abstractmethod
    def to_qasm(self) -> str: ...
    @staticmethod
    def from_cirq(cirq_circuit: cirq.Circuit, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_pennylane(pennylane_circuit: qml.QNode, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_qiskit(qiskit_circuit: qiskit.QuantumCircuit, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_tket(tket_circuit: pytket.Circuit, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_qasm(qasm: str, output_framework: Type[Circuit]) -> Circuit: ...
    def reset(self) -> None: ...
    @abstractmethod
    def draw(self): ...
    def plot_histogram(self, non_zeros_only: bool = False) -> plt.Figure: ...
    def __eq__(self, other_circuit: object) -> bool: ...
    def __len__(self) -> int: ...
    @classmethod
    def __subclasscheck__(cls, C) -> bool: ...
    @classmethod
    def __subclasshook__(cls, C) -> bool | NotImplementedType: ...
    @classmethod
    def __instancecheck__(cls, C) -> bool: ...
