import abc
import cirq
import matplotlib.pyplot as plt
import numpy as np
import pennylane as qml # type: ignore
import pytket
import qiskit # type: ignore
from abc import ABC, abstractmethod
from numpy.typing import NDArray
from qickit.backend import Backend
from qickit.types import Collection, Circuit_Type
from types import NotImplementedType
from typing import Callable, Type

__all__ = ['Circuit']

class Circuit(ABC, metaclass=abc.ABCMeta):
    num_qubits: int
    num_clbits: int
    circuit: Circuit_Type
    measured: bool
    circuit_log: list[dict]
    def __init__(self, num_qubits: int, num_clbits: int) -> None: ...
    @staticmethod
    def gatemethod(method: Callable) -> Callable: ...
    @abstractmethod
    def Identity(self, qubit_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def X(self, qubit_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def Y(self, qubit_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def Z(self, qubit_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def H(self, qubit_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def S(self, qubit_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def T(self, qubit_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def RX(self, angle: float, qubit_index: int) -> None: ...
    @abstractmethod
    def RY(self, angle: float, qubit_index: int) -> None: ...
    @abstractmethod
    def RZ(self, angle: float, qubit_index: int) -> None: ...
    @abstractmethod
    def U3(self, angles: Collection[float], qubit_index: int) -> None: ...
    @abstractmethod
    def SWAP(self, first_qubit: int, second_qubit: int) -> None: ...
    @abstractmethod
    def CX(self, control_index: int, target_index: int) -> None: ...
    @abstractmethod
    def CY(self, control_index: int, target_index: int) -> None: ...
    @abstractmethod
    def CZ(self, control_index: int, target_index: int) -> None: ...
    @abstractmethod
    def CH(self, control_index: int, target_index: int) -> None: ...
    @abstractmethod
    def CS(self, control_index: int, target_index: int) -> None: ...
    @abstractmethod
    def CT(self, control_index: int, target_index: int) -> None: ...
    @abstractmethod
    def CRX(self, angle: float, control_index: int, target_index: int) -> None: ...
    @abstractmethod
    def CRY(self, angle: float, control_index: int, target_index: int) -> None: ...
    @abstractmethod
    def CRZ(self, angle: float, control_index: int, target_index: int) -> None: ...
    @abstractmethod
    def CU3(self, angles: Collection[float], control_index: int, target_index: int) -> None: ...
    @abstractmethod
    def CSWAP(self, control_index: int, first_target_index: int, second_target_index: int) -> None: ...
    @abstractmethod
    def MCX(self, control_indices: int | Collection[int], target_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def MCY(self, control_indices: int | Collection[int], target_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def MCZ(self, control_indices: int | Collection[int], target_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def MCH(self, control_indices: int | Collection[int], target_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def MCS(self, control_indices: int | Collection[int], target_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def MCT(self, control_indices: int | Collection[int], target_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def MCRX(self, angle: float, control_indices: int | Collection[int], target_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def MCRY(self, angle: float, control_indices: int | Collection[int], target_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def MCRZ(self, angle: float, control_indices: int | Collection[int], target_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def MCU3(self, angles: Collection[float], control_indices: int | Collection[int], target_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def MCSWAP(self, control_indices: int | Collection[int], first_target_index: int, second_target_index: int) -> None: ...
    @abstractmethod
    def GlobalPhase(self, angle: float) -> None: ...
    def unitary(self, unitary_matrix: NDArray[np.number], qubit_indices: int | Collection[int]) -> None: ...
    def vertical_reverse(self) -> None: ...
    def horizontal_reverse(self, adjoint: bool = True) -> None: ...
    def add(self, circuit: Circuit, qubit_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def measure(self, qubit_indices: int | Collection[int]) -> None: ...
    @abstractmethod
    def get_statevector(self, backend: Backend | None = None) -> Collection[float]: ...
    @abstractmethod
    def get_counts(self, num_shots: int, backend: Backend | None = None) -> dict[str, int]: ...
    @abstractmethod
    def get_depth(self) -> int: ...
    def get_width(self) -> int: ...
    @abstractmethod
    def get_unitary(self) -> NDArray[np.number]: ...
    @abstractmethod
    def transpile(self) -> None: ...
    def compress(self, compression_percentage: float) -> None: ...
    def change_mapping(self, qubit_indices: Collection[int]) -> None: ...
    def convert(self, circuit_framework: Type[Circuit]) -> Circuit: ...
    @abstractmethod
    def to_qasm(self) -> str: ...
    @staticmethod
    def from_cirq(cirq_circuit: cirq.Circuit, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_pennylane(pennylane_circuit: qml.QNode, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_qiskit(qiskit_circuit: qiskit.QuantumCircuit, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_tket(tket_circuit: pytket.Circuit, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_qasm(qasm: str, output_framework: Type[Circuit]) -> Circuit: ...
    def reset(self) -> None: ...
    @abstractmethod
    def draw(self): ...
    def plot_histogram(self, non_zeros_only: bool = False) -> plt.Figure: ...
    def __eq__(self, other_circuit: object) -> bool: ...
    def __len__(self) -> int: ...
    @classmethod
    def __subclasscheck__(cls, C) -> bool: ...
    @classmethod
    def __subclasshook__(cls, C) -> bool | NotImplementedType: ...
    @classmethod
    def __instancecheck__(cls, C) -> bool: ...
